//
// SydBâ˜®x: SydBâ˜®x' Rust API
// sydbox.rs: Main entry point
//
// Copyright (c) 2021 Ali Polatel <alip@exherbo.org>
// Based in part upon unshare/examples/runcmd.rs which is
//   Copyright (c) 2015-2016 The unshare Developers
//   Released under the terms of the MIT License.
//
// SPDX-License-Identifier: GPL-2.0-only

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

extern crate libc;
extern crate unshare;

use unshare::*;

use std::ffi::CStr;
use std::ffi::OsStr;
use std::os::unix::ffi::OsStrExt;

use std::io::Read;

use libc::{c_char, gid_t};
pub use nix::sys::signal::Signal;

#[doc = "Print SydBâ˜®x version and build details to standard error."]
#[no_mangle]
pub extern "C" fn syd_about() {
    let sv: scmp_version = Default::default();

    eprintln!(
        "[0;1;31;91m{}-{}{}[0m",
        "@SYD_PACKAGE@", "@SYD_VERSION@", "@SYD_GITVERSION@"
    );
    eprintln!(
        "[0;1;31;91mUsing libseccomp v{}.{}.{}[0m",
        sv.major, sv.minor, sv.micro
    );
    eprint!("[0;1;31;91mOptions: ");
    eprint!("dump:{}", "@DUMP_BUILTIN@");
    eprint!("seccomp:yes");
    eprint!(" ipv6:yes");
    eprintln!(" netlink:yes[0m");
    eprintln!("[0;1;32;91mCopyright Â© 2010, 2011, 2012, 2013, 2014, 2015, 2018, 2020, 2021[0m");
    eprintln!("[0;1;34;91mAlÃ¯ Pâ˜®latel <alÃ¯p@exherbâ˜®.â˜®rg>[0m");
    eprintln!("SPDX-License-Identifier: [0;1;31;91mGPL-2.0-only[0m");
}

#[must_use]
#[no_mangle]
#[doc = "Execute a process under various restrictions and options."]
pub extern "C" fn syd_execv(
    command: *const c_char,
    args: *mut *mut c_char,
    alias: *const c_char,
    workdir: *const c_char,
    verbose: bool,
    uid: u32,
    gid: u32,
    chroot: *const c_char,
    new_root: *const c_char,
    put_old: *const c_char,
    unshare_pid: bool,
    unshare_net: bool,
    unshare_mount: bool,
    unshare_uts: bool,
    unshare_ipc: bool,
    unshare_user: bool,
    close_fds_beg: i32,
    close_fds_end: i32,
    reset_fds: bool,
    escape_stdout: bool,
    allow_daemonize: bool,
    parent_death_signal: i32,
    supplementary_gids: *const u32,
    pid_env_var: *const c_char,
) -> i32 {
    let mut argv = Vec::<&str>::new();
    for arg in unsafe { args.as_ref() }.iter() {
        let slice = unsafe { CStr::from_ptr(**arg) };
        let osstr = OsStr::from_bytes(slice.to_bytes());
        match osstr.to_str() {
            Some(s) => argv.push(s),
            None => {}
        }
    }
    let mut slice = unsafe { CStr::from_ptr(command) };
    let mut osstr = OsStr::from_bytes(slice.to_bytes());
    let mut cmd = unshare::Command::new(osstr);
    cmd.args(&argv);

    slice = unsafe { CStr::from_ptr(alias) };
    osstr = OsStr::from_bytes(slice.to_bytes());
    match osstr.to_str() {
        Some(s) => {
            if !s.is_empty() {
                cmd.arg0(s);
            }
        }
        None => {}
    };

    slice = unsafe { CStr::from_ptr(workdir) };
    osstr = OsStr::from_bytes(slice.to_bytes());
    match osstr.to_str() {
        Some(s) => {
            if !s.is_empty() {
                cmd.current_dir(s);
            }
        }
        None => {}
    };

    if uid != 0 {
        cmd.uid(uid);
    }
    if gid != 0 {
        cmd.gid(gid);
    }

    let mut gids = Vec::<gid_t>::new();
    for arg in unsafe { supplementary_gids.as_ref() }.iter() {
        gids.push(**arg);
    }
    if gids.len() > 0 {
        cmd.groups(gids);
    }

    slice = unsafe { CStr::from_ptr(chroot) };
    osstr = OsStr::from_bytes(slice.to_bytes());
    if let Some(s) = osstr.to_str() {
        if !s.is_empty() {
            cmd.chroot_dir(s);
        }
    }

    slice = unsafe { CStr::from_ptr(new_root) };
    osstr = OsStr::from_bytes(slice.to_bytes());
    if let Some(s0) = osstr.to_str() {
        slice = unsafe { CStr::from_ptr(put_old) };
        osstr = OsStr::from_bytes(slice.to_bytes());
        if let Some(s1) = osstr.to_str() {
            if !s0.is_empty() && !s1.is_empty() {
                cmd.pivot_root(s0, s1, true);
            }
        }
    }

    let mut namespaces = Vec::<Namespace>::new();
    if unshare_pid {
        namespaces.push(Namespace::Pid);
    }
    if unshare_net {
        namespaces.push(Namespace::Net);
    }
    if unshare_mount {
        namespaces.push(Namespace::Mount);
    }
    if unshare_uts {
        namespaces.push(Namespace::Uts);
    }
    if unshare_ipc {
        namespaces.push(Namespace::Ipc);
    }
    if unshare_user {
        namespaces.push(Namespace::User);
    }
    cmd.unshare(&namespaces);

    if reset_fds {
        cmd.reset_fds();
    }

    if close_fds_beg == 0 && close_fds_end == 0 {
        /* do nothing */
    } else if close_fds_beg == 3 && close_fds_end == 0 {
        cmd.close_fds(..);
    } else if close_fds_beg != 0 && close_fds_end == 0 {
        cmd.close_fds(close_fds_beg..);
    } else {
        cmd.close_fds(close_fds_beg..close_fds_end);
    }

    if escape_stdout {
        cmd.stdout(unshare::Stdio::piped());
    }

    if parent_death_signal > 0 {
        cmd.set_parent_death_signal(Signal::from(parent_death_signal));
    }

    if allow_daemonize {
        cmd.allow_daemonize();
    }

    slice = unsafe { CStr::from_ptr(pid_env_var) };
    osstr = OsStr::from_bytes(slice.to_bytes());
    if let Some(s) = osstr.to_str() {
        if !s.is_empty() {
            cmd.env_var_with_pid(s);
        }
    }

    if verbose {
        eprintln!("[0;1;31;91mSydbâ˜®x Câ˜®mmand: {:?}[0m", cmd);
    }

    let mut child = match cmd.spawn() {
        Ok(child) => child,
        Err(e) => {
            eprintln!("[0;1;31;91mSydbâ˜®x Câ˜®mmand Error: {}[0m", e);
            return 127;
        }
    };

    if verbose {
        eprintln!("[0;1;31;91mSydbâ˜®x Child pid: {}[0m", child.id());
    }

    if escape_stdout {
        let mut buf = Vec::new();
        child.stdout.take().unwrap().read_to_end(&mut buf).unwrap();
        eprintln!("[0;1;31;91m{:?}[0m", String::from_utf8_lossy(&buf[..]));
    }
    let res = child.wait().unwrap();
    if verbose {
        eprintln!("[0;1;31;91mSydbâ˜®x [pid {}] {}[0m", child.id(), res);
    }

    0
}

#[doc = "This structure represents a seccomp version"]
#[repr(C)]
pub struct scmp_version {
    pub major: u8,
    pub minor: u8,
    pub micro: u8,
}

impl Default for scmp_version {
    fn default() -> Self {
        unsafe {
            let version = seccomp_version();
            Self {
                major: (*version).major,
                minor: (*version).minor,
                micro: (*version).micro,
            }
        }
    }
}

extern "C" {
    fn seccomp_version() -> *const scmp_version;
}

#[allow(dead_code)]
fn main() {
    syd_about();
    std::process::exit(0);
}
